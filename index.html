<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>FPS game</title>

<style>
html,body{
  height:100%;
  margin:0;
  background:#111;
  color:#eee;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  overflow:hidden;
}
canvas{display:block}

#ui{position:fixed;inset:0;pointer-events:none}
#hud{position:absolute;top:12px;left:12px;font:14px monospace}
#cross{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:22px}
#help{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);
  background:rgba(0,0,0,.6);padding:8px 12px;border-radius:8px;font-size:13px}

#btn{
  position:absolute;top:12px;right:12px;
  pointer-events:auto;
  padding:8px 14px;
  border:0;border-radius:8px;
  background:#2a86ff;color:#fff;
  cursor:pointer;
}
#notice{
  position:absolute;top:70px;left:50%;transform:translateX(-50%);
  background:rgba(0,0,0,.75);
  padding:8px 12px;border-radius:8px;
  display:none;font-size:13px;
}
.paused #cross{opacity:.4}
</style>
</head>
<body>

<div id="ui">
  <div id="hud">
    HP <span id="hp">100</span> |
    Ammo <span id="ammo">30</span> |
    Score <span id="score">0</span>
  </div>
  <div id="cross">+</div>
  <div id="help">WASD move · Mouse look · Click shoot · R reload · P pause</div>
  <div id="notice">Pointer-lock blocked — click & drag to look</div>
  <button id="btn">Play</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
/* =========================
   BASIC SETUP
========================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87a7ff);

const camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,500);
camera.position.set(0,1.6,6);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

/* =========================
   LIGHTS & WORLD
========================= */
scene.add(new THREE.AmbientLight(0x888888));
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(5,10,5);
scene.add(sun);

const floor=new THREE.Mesh(
  new THREE.PlaneGeometry(300,300),
  new THREE.MeshStandardMaterial({color:0x445544})
);
floor.rotation.x=-Math.PI/2;
scene.add(floor);

/* =========================
   UI
========================= */
const $=id=>document.getElementById(id);
const hpEl=$("hp"),ammoEl=$("ammo"),scoreEl=$("score");
const btn=$("btn"),notice=$("notice"),ui=$("ui");

/* =========================
   PLAYER STATE
========================= */
let yaw=0,pitch=0;
let move={w:0,a:0,s:0,d:0};
let ammo=30,score=0,hp=100;
let paused=true;
const speed=5;
  let thirdPerson = false;
const thirdPersonDist = 6;
let cameraBasePosition = new THREE.Vector3(0, 1.6, 6);


/* =========================
   POINTER LOCK SAFE
========================= */
let pointerLocked=false;
let fallback=false,dragging=false,lastX=0,lastY=0;
const canvas=renderer.domElement;

btn.onclick=()=>{
  if(paused){
    paused=false;
    ui.classList.remove("paused");
    try{canvas.requestPointerLock();}
    catch{fallback=true;notice.style.display="block";}
  }
};

document.addEventListener("pointerlockchange",()=>{
  pointerLocked=document.pointerLockElement===canvas;
  if(pointerLocked){
    fallback=false;
    notice.style.display="none";
    btn.style.display="none";
    canvas.style.cursor="none";
  }else{
    btn.style.display="block";
    canvas.style.cursor="crosshair";
  }
});

document.addEventListener("pointerlockerror",()=>{
  fallback=true;
  notice.style.display="block";
});

/* =========================
   INPUT
========================= */
addEventListener("keydown",e=>{
  if(e.key in move) move[e.key]=1;
  if(e.key==="r"&&ammo<30) setTimeout(()=>ammo=30,800);
  if(e.key==="p") paused=!paused,ui.classList.toggle("paused",paused);
});
addEventListener("keyup",e=>{if(e.key in move) move[e.key]=0;});

canvas.onmousedown=e=>{
  if(fallback&&!pointerLocked){
    dragging=true;lastX=e.clientX;lastY=e.clientY;
    canvas.style.cursor="none";
  }
  if(e.button===0&&!paused) shoot();
};
canvas.onmouseup=()=>{dragging=false;canvas.style.cursor="crosshair";};

addEventListener("mousemove",e=>{
  if(paused) return;
  let dx=0,dy=0;
  if(pointerLocked){dx=e.movementX;dy=e.movementY;}
  else if(fallback&&dragging){
    dx=e.clientX-lastX;dy=e.clientY-lastY;
    lastX=e.clientX;lastY=e.clientY;
  }
  yaw-=dx*0.0025;
  pitch=Math.max(-1.55,Math.min(1.55,pitch-dy*0.0025));
});
/* =========================
   GAMEPAD SUPPORT
========================= */
let gamepadIndex = null;
let lastButtons = [];

addEventListener("gamepadconnected", e => {
  gamepadIndex = e.gamepad.index;
  console.log("Gamepad connected");
});
addEventListener("gamepaddisconnected", () => {
  gamepadIndex = null;
  console.log("Gamepad disconnected");
});

function handleGamepad(dt){
  if(gamepadIndex === null) return;
  const gp = navigator.getGamepads()[gamepadIndex];
  if(!gp) return;

  // --- sticks ---
  const lx = gp.axes[0]; // left stick X
  const ly = gp.axes[1]; // left stick Y
  const rx = gp.axes[2]; // right stick X
  const ry = gp.axes[3]; // right stick Y

  // deadzone
  const dz = 0.15;

  move.w = ly < -dz ? 1 : 0;
  move.s = ly >  dz ? 1 : 0;
  move.a = lx < -dz ? 1 : 0;
  move.d = lx >  dz ? 1 : 0;

  // look
  yaw   -= rx * 2.5 * dt;
  pitch -= ry * 2.5 * dt;
  pitch = Math.max(-1.55, Math.min(1.55, pitch));

  // --- buttons ---
  gp.buttons.forEach((b, i) => {
    const pressed = b.pressed;
    const wasPressed = lastButtons[i];

    // RT / R2 → shoot ON PRESS (not hold)
if (i === 7 && pressed && !wasPressed && !paused) {
  shoot();
}

// D-Pad Up → toggle perspective
if (i === 12 && pressed && !wasPressed) {
  thirdPerson = !thirdPerson;
}

    // X / Square → reload
    if(i === 2 && pressed && !wasPressed && ammo < 30){
      setTimeout(()=>ammo=30,800);
    }

    // Start / Options → pause
    if(i === 9 && pressed && !wasPressed){
      paused = !paused;
      ui.classList.toggle("paused", paused);
    }

    lastButtons[i] = pressed;
  });
}
/* =========================
   MOBILE FPS CONTROLS
========================= */
if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {

  /* --- Left: Arrow keys for movement --- */
  const mobileUI = document.createElement('div');
  mobileUI.style.position = 'fixed';
  mobileUI.style.bottom = '50px';
  mobileUI.style.left = '50px';
  mobileUI.style.width = '150px';
  mobileUI.style.height = '150px';
  mobileUI.style.pointerEvents = 'auto';
  document.body.appendChild(mobileUI);

  const createBtn = (text, x, y) => {
    const btn = document.createElement('button');
    btn.textContent = text;
    btn.style.position = 'absolute';
    btn.style.width = '50px';
    btn.style.height = '50px';
    btn.style.left = `${x}px`;
    btn.style.top = `${y}px`;
    btn.style.borderRadius = '10px';
    btn.style.background = 'rgba(0,0,0,0.5)';
    btn.style.color = '#fff';
    btn.style.fontSize = '24px';
    btn.style.border = 'none';
    btn.style.touchAction = 'none';
    mobileUI.appendChild(btn);
    return btn;
  };

  const buttons = {
    w: createBtn('↑', 50, 0),
    a: createBtn('←', 0, 50),
    s: createBtn('↓', 50, 100),
    d: createBtn('→', 100, 50)
  };

  for (let key in buttons) {
    buttons[key].addEventListener('touchstart', e=>{
      e.preventDefault(); move[key]=1;
    });
    buttons[key].addEventListener('touchend', e=>{
      e.preventDefault(); move[key]=0;
    });
  }

  /* --- Right: Virtual joystick for looking --- */
  const lookJoystick = document.createElement('div');
  lookJoystick.style.position = 'fixed';
  lookJoystick.style.right = '50px';
  lookJoystick.style.bottom = '50px';
  lookJoystick.style.width = '120px';
  lookJoystick.style.height = '120px';
  lookJoystick.style.borderRadius = '50%';
  lookJoystick.style.background = 'rgba(0,0,0,0.3)';
  lookJoystick.style.touchAction = 'none';
  document.body.appendChild(lookJoystick);

  let draggingLook = false;
  let lastX = 0, lastY = 0;

  lookJoystick.addEventListener('touchstart', e=>{
    e.preventDefault();
    draggingLook = true;
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;
  });

  lookJoystick.addEventListener('touchmove', e=>{
    if(!draggingLook) return;
    e.preventDefault();
    const dx = e.touches[0].clientX - lastX;
    const dy = e.touches[0].clientY - lastY;
    lastX = e.touches[0].clientX;
    lastY = e.touches[0].clientY;

    // adjust sensitivity
    const sensitivity = 0.0025;
    yaw -= dx * sensitivity;
    pitch = Math.max(-1.55, Math.min(1.55, pitch - dy * sensitivity));
  });

  lookJoystick.addEventListener('touchend', e=>{
    e.preventDefault();
    draggingLook = false;
  });

  // optional: add a shoot button near right joystick
  const shootBtn = document.createElement('button');
  shootBtn.textContent = '●';
  shootBtn.style.position = 'fixed';
  shootBtn.style.right = '50px';
  shootBtn.style.bottom = '200px';
  shootBtn.style.width = '60px';
  shootBtn.style.height = '60px';
  shootBtn.style.borderRadius = '50%';
  shootBtn.style.background = 'rgba(255,0,0,0.7)';
  shootBtn.style.color = '#fff';
  shootBtn.style.fontSize = '24px';
  shootBtn.style.border = 'none';
  shootBtn.style.touchAction = 'none';
  document.body.appendChild(shootBtn);

  shootBtn.addEventListener('touchstart', e=>{
    e.preventDefault();
    shoot();
  });
}

/* =========================
   ENEMIES
========================= */
const enemies = []; // only declare once

function createHumanEnemy() {
  const group = new THREE.Group();

  const bodyMat = new THREE.MeshStandardMaterial({color: 0xaa4444});

  // body
  const body = new THREE.Mesh(new THREE.BoxGeometry(1,1.5,0.5), bodyMat);
  body.position.y = 0.75;
  group.add(body);

  // head
  const head = new THREE.Mesh(new THREE.BoxGeometry(0.6,0.6,0.6), bodyMat);
  head.position.y = 1.8;
  group.add(head);

  // left arm
  const lArm = new THREE.Mesh(new THREE.BoxGeometry(0.3,1,0.3), bodyMat);
  lArm.position.set(-0.65, 1.0, 0);
  group.add(lArm);

  // right arm
  const rArm = new THREE.Mesh(new THREE.BoxGeometry(0.3,1,0.3), bodyMat);
  rArm.position.set(0.65, 1.0, 0);
  group.add(rArm);

  // left leg
  const lLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3,1,0.3), bodyMat);
  lLeg.position.set(-0.25, -0.5, 0);
  group.add(lLeg);

  // right leg
  const rLeg = new THREE.Mesh(new THREE.BoxGeometry(0.3,1,0.3), bodyMat);
  rLeg.position.set(0.25, -0.5, 0);
  group.add(rLeg);

  // position and userData
  group.position.y = 0.5;
  group.userData = {hp:3, speed:1+Math.random()};

  scene.add(group);
  enemies.push(group); // make sure to add it to enemies array

  return group;
}

// spawn 6 enemies
for(let i=0;i<6;i++){
  const a = Math.random()*Math.PI*2;
  const d = 30 + Math.random()*20;
  const e = createHumanEnemy();
  e.position.set(Math.cos(a)*d,0.5,Math.sin(a)*d);
}
  
/* =========================
   SHOOTING
========================= */
const ray=new THREE.Raycaster();
function shoot(){
  if(ammo <= 0) return;
  ammo--;
  ray.set(camera.position, camera.getWorldDirection(new THREE.Vector3()));

  // intersect all child meshes of enemies groups
  const hit = ray.intersectObjects(enemies, true)[0]; // "true" = recursive
  if(hit){
    const enemy = hit.object.parent; // get the group
    if(!enemy.userData.hp) return;   // safety check

    enemy.userData.hp--;
    
    // optional: small knockback on the whole group
    const dir = ray.ray.direction.clone();
    enemy.position.addScaledVector(dir, -0.3);

    if(enemy.userData.hp <= 0){
      score += 10;
      scene.remove(enemy);
      enemies.splice(enemies.indexOf(enemy), 1);
      // spawn two new enemies
      const a = Math.random()*Math.PI*2;
      const d = 30 + Math.random()*20;
      const e = createHumanEnemy();
      e.position.set(Math.cos(a)*d, 0.5, Math.sin(a)*d);

      const a2 = Math.random()*Math.PI*2;
      const d2 = 30 + Math.random()*20;
      const e2 = createHumanEnemy();
      e2.position.set(Math.cos(a2)*d2, 0.5, Math.sin(a2)*d2);
    }
  }
}


/* =========================
   LOOP
========================= */
let last = performance.now();
function loop(now){
  requestAnimationFrame(loop);
  const dt=Math.min(.05,(now-last)/1000);
  last=now;

  if(!paused){
    camera.rotation.order = "YXZ";
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;
if (thirdPerson) {
  // camera is offset behind the player
  const offset = new THREE.Vector3(0, 1.6, thirdPersonDist); // up + back
  offset.applyAxisAngle(new THREE.Vector3(0,1,0), yaw); // rotate with player

  camera.position.copy(camera.positionStart.clone().add(offset));
} else {
  // first-person: camera at player position
  camera.position.copy(camera.positionStart);
}

    handleGamepad(dt);
    // update the player position
const dir = new THREE.Vector3(move.d - move.a, 0, move.s - move.w)
  .normalize()
  .applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
cameraBasePosition.addScaledVector(dir, speed*dt);

// then use cameraBasePosition in the third-person offset calculation
if (thirdPerson) {
  const offset = new THREE.Vector3(0, 1.6, thirdPersonDist);
  offset.applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
  camera.position.copy(cameraBasePosition.clone().add(offset));
} else {
  camera.position.copy(cameraBasePosition);
}

    enemies.forEach(e => {
      // move toward player
      const v = new THREE.Vector3().subVectors(camera.position, e.position);
      v.y = 0;
      const dist = v.length();
      v.normalize();
      e.position.addScaledVector(v, e.userData.speed * dt);

      // cooldown damage
      if(dist < 1){
        if(!e.userData.lastHit || performance.now() - e.userData.lastHit > 500){
          hp -= 10;               // damage
          hp = Math.max(0, hp);   // clamp
          e.userData.lastHit = performance.now();
        }
      }
    });
  }

  // update UI
  hpEl.textContent = hp;
  ammoEl.textContent = ammo;
  scoreEl.textContent = score;

  renderer.render(scene, camera);
}

// start the loop
loop(performance.now());
</script>
</body>
</html>
