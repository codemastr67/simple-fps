<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Simple FPS — Three.js (Pointer-Lock Safe)</title>

<style>
html,body{
  height:100%;
  margin:0;
  background:#111;
  color:#eee;
  font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;
  overflow:hidden;
}
canvas{display:block}

#ui{position:fixed;inset:0;pointer-events:none}
#hud{position:absolute;top:12px;left:12px;font:14px monospace}
#cross{position:absolute;left:50%;top:50%;transform:translate(-50%,-50%);font-size:22px}
#help{position:absolute;bottom:20px;left:50%;transform:translateX(-50%);
  background:rgba(0,0,0,.6);padding:8px 12px;border-radius:8px;font-size:13px}

#btn{
  position:absolute;top:12px;right:12px;
  pointer-events:auto;
  padding:8px 14px;
  border:0;border-radius:8px;
  background:#2a86ff;color:#fff;
  cursor:pointer;
}
#notice{
  position:absolute;top:70px;left:50%;transform:translateX(-50%);
  background:rgba(0,0,0,.75);
  padding:8px 12px;border-radius:8px;
  display:none;font-size:13px;
}
.paused #cross{opacity:.4}
</style>
</head>
<body>

<div id="ui">
  <div id="hud">
    HP <span id="hp">100</span> |
    Ammo <span id="ammo">30</span> |
    Score <span id="score">0</span>
  </div>
  <div id="cross">+</div>
  <div id="help">WASD move · Mouse look · Click shoot · R reload · P pause</div>
  <div id="notice">Pointer-lock blocked — click & drag to look</div>
  <button id="btn">Play</button>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script>
/* =========================
   BASIC SETUP
========================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87a7ff);

const camera = new THREE.PerspectiveCamera(75,innerWidth/innerHeight,0.1,500);
camera.position.set(0,1.6,6);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(innerWidth,innerHeight);
document.body.appendChild(renderer.domElement);

addEventListener('resize',()=>{
  camera.aspect=innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth,innerHeight);
});

/* =========================
   LIGHTS & WORLD
========================= */
scene.add(new THREE.AmbientLight(0x888888));
const sun=new THREE.DirectionalLight(0xffffff,1);
sun.position.set(5,10,5);
scene.add(sun);

const floor=new THREE.Mesh(
  new THREE.PlaneGeometry(300,300),
  new THREE.MeshStandardMaterial({color:0x445544})
);
floor.rotation.x=-Math.PI/2;
scene.add(floor);

/* =========================
   UI
========================= */
const $=id=>document.getElementById(id);
const hpEl=$("hp"),ammoEl=$("ammo"),scoreEl=$("score");
const btn=$("btn"),notice=$("notice"),ui=$("ui");

/* =========================
   PLAYER STATE
========================= */
let yaw=0,pitch=0;
let move={w:0,a:0,s:0,d:0};
let ammo=30,score=0,hp=100;
let paused=true;
const speed=5;
  let thirdPerson = false;
const thirdPersonDist = 6;


/* =========================
   POINTER LOCK SAFE
========================= */
let pointerLocked=false;
let fallback=false,dragging=false,lastX=0,lastY=0;
const canvas=renderer.domElement;

btn.onclick=()=>{
  if(paused){
    paused=false;
    ui.classList.remove("paused");
    try{canvas.requestPointerLock();}
    catch{fallback=true;notice.style.display="block";}
  }
};

document.addEventListener("pointerlockchange",()=>{
  pointerLocked=document.pointerLockElement===canvas;
  if(pointerLocked){
    fallback=false;
    notice.style.display="none";
    btn.style.display="none";
    canvas.style.cursor="none";
  }else{
    btn.style.display="block";
    canvas.style.cursor="crosshair";
  }
});

document.addEventListener("pointerlockerror",()=>{
  fallback=true;
  notice.style.display="block";
});

/* =========================
   INPUT
========================= */
addEventListener("keydown",e=>{
  if(e.key in move) move[e.key]=1;
  if(e.key==="r"&&ammo<30) setTimeout(()=>ammo=30,800);
  if(e.key==="p") paused=!paused,ui.classList.toggle("paused",paused);
});
addEventListener("keyup",e=>{if(e.key in move) move[e.key]=0;});

canvas.onmousedown=e=>{
  if(fallback&&!pointerLocked){
    dragging=true;lastX=e.clientX;lastY=e.clientY;
    canvas.style.cursor="none";
  }
  if(e.button===0&&!paused) shoot();
};
canvas.onmouseup=()=>{dragging=false;canvas.style.cursor="crosshair";};

addEventListener("mousemove",e=>{
  if(paused) return;
  let dx=0,dy=0;
  if(pointerLocked){dx=e.movementX;dy=e.movementY;}
  else if(fallback&&dragging){
    dx=e.clientX-lastX;dy=e.clientY-lastY;
    lastX=e.clientX;lastY=e.clientY;
  }
  yaw-=dx*0.0025;
  pitch=Math.max(-1.55,Math.min(1.55,pitch-dy*0.0025));
});
/* =========================
   GAMEPAD SUPPORT
========================= */
let gamepadIndex = null;
let lastButtons = [];

addEventListener("gamepadconnected", e => {
  gamepadIndex = e.gamepad.index;
  console.log("Gamepad connected");
});
addEventListener("gamepaddisconnected", () => {
  gamepadIndex = null;
  console.log("Gamepad disconnected");
});

function handleGamepad(dt){
  if(gamepadIndex === null) return;
  const gp = navigator.getGamepads()[gamepadIndex];
  if(!gp) return;

  // --- sticks ---
  const lx = gp.axes[0]; // left stick X
  const ly = gp.axes[1]; // left stick Y
  const rx = gp.axes[2]; // right stick X
  const ry = gp.axes[3]; // right stick Y

  // deadzone
  const dz = 0.15;

  move.w = ly < -dz ? 1 : 0;
  move.s = ly >  dz ? 1 : 0;
  move.a = lx < -dz ? 1 : 0;
  move.d = lx >  dz ? 1 : 0;

  // look
  yaw   -= rx * 2.5 * dt;
  pitch -= ry * 2.5 * dt;
  pitch = Math.max(-1.55, Math.min(1.55, pitch));

  // --- buttons ---
  gp.buttons.forEach((b, i) => {
    const pressed = b.pressed;
    const wasPressed = lastButtons[i];

    // RT / R2 → shoot ON PRESS (not hold)
if (i === 7 && pressed && !wasPressed && !paused) {
  shoot();
}

// D-Pad Up → toggle perspective
if (i === 12 && pressed && !wasPressed) {
  thirdPerson = !thirdPerson;
}

    // X / Square → reload
    if(i === 2 && pressed && !wasPressed && ammo < 30){
      setTimeout(()=>ammo=30,800);
    }

    // Start / Options → pause
    if(i === 9 && pressed && !wasPressed){
      paused = !paused;
      ui.classList.toggle("paused", paused);
    }

    lastButtons[i] = pressed;
  });
}

/* =========================
   ENEMIES
========================= */
const enemies=[];
function spawnEnemy(){
  if(enemies.length>20) return;
  const m=new THREE.Mesh(
    new THREE.BoxGeometry(1,1,1),
    new THREE.MeshStandardMaterial({color:0xaa4444})
  );
  const a=Math.random()*Math.PI*2,d=30+Math.random()*20;
  m.position.set(Math.cos(a)*d,0.5,Math.sin(a)*d);
  m.userData={hp:3,speed:1+Math.random()};
  scene.add(m);enemies.push(m);
}
for(let i=0;i<6;i++)spawnEnemy();

/* =========================
   SHOOTING
========================= */
const ray=new THREE.Raycaster();
function shoot(){
  if(ammo<=0) return;
  ammo--;
  ray.set(camera.position,camera.getWorldDirection(new THREE.Vector3()));
  const hit=ray.intersectObjects(enemies)[0];
  if(hit){
    hit.object.userData.hp--;
    hit.object.position.addScaledVector(ray.ray.direction,-0.3);
    if(hit.object.userData.hp<=0){
      score+=10;
      scene.remove(hit.object);
      enemies.splice(enemies.indexOf(hit.object),1);
      spawnEnemy();spawnEnemy();
    }
  }
}

/* =========================
   LOOP
========================= */
let last = performance.now();
function loop(now){
  requestAnimationFrame(loop);
  const dt=Math.min(.05,(now-last)/1000);
  last=now;

  if(!paused){
    camera.rotation.order = "YXZ";
    camera.rotation.y = yaw;
    camera.rotation.x = pitch;

    if (thirdPerson) {
      const offset = new THREE.Vector3(0, 1.6, thirdPersonDist)
        .applyAxisAngle(new THREE.Vector3(0,1,0), yaw);

      camera.position
        .copy(camera.position)
        .add(offset);
    }

    handleGamepad(dt);
    const dir = new THREE.Vector3(
      move.d-move.a, 0, move.s-move.w
    ).normalize().applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
    camera.position.addScaledVector(dir, speed*dt);

    enemies.forEach(e => {
      // move toward player
      const v = new THREE.Vector3().subVectors(camera.position, e.position);
      v.y = 0;
      const dist = v.length();
      v.normalize();
      e.position.addScaledVector(v, e.userData.speed * dt);

      // cooldown damage
      if(dist < 1){
        if(!e.userData.lastHit || performance.now() - e.userData.lastHit > 500){
          hp -= 10;               // damage
          hp = Math.max(0, hp);   // clamp
          e.userData.lastHit = performance.now();
        }
      }
    });
  }

  // update UI
  hpEl.textContent = hp;
  ammoEl.textContent = ammo;
  scoreEl.textContent = score;

  renderer.render(scene, camera);
}

// start the loop
loop(performance.now());
</script>
</body>
</html>
